# Cocktail App - Backend

Este mÃ³dulo corresponde al Backend de la aplicaciÃ³n de gestiÃ³n de cÃ³cteles. Consiste en una API RESTful desarrollada en **Node.js** (v18) con **TypeScript**, utilizando **Express** como servidor y **PostgreSQL** como base de datos.

ğŸ“‹ **Requisitos Previos**

Para garantizar el correcto funcionamiento, se recomienda contar con las siguientes versiones (o superiores) en el entorno de ejecuciÃ³n:

- **Node.js:** VersiÃ³n 18 (Recomendada: v18.17.1 o superior).

- **PostgreSQL:** VersiÃ³n 18.

> **Nota:** El proyecto implementa caracterÃ­sticas modernas de ES Modules y Express 5, por lo que versiones antiguas de Node.js podrÃ­an presentar incompatibilidades.

## ğŸš€ InstalaciÃ³n y ConfiguraciÃ³n

1. **InstalaciÃ³n de Dependencias**

Para instalar todas las librerÃ­as necesarias, ejecutar el siguiente comando en la raÃ­z de este directorio (` backend/ `):

``` bash npm install ``` 

2. **ConfiguraciÃ³n de Variables de Entorno**

Es necesario crear un archivo ` .env ` en la raÃ­z de la carpeta ` backend ` con las credenciales de la base de datos local. Se puede tomar como referencia la siguiente configuraciÃ³n:

``` 
PORT=3000 
DB_HOST=localhost 
DB_PORT=5432 
DB_USER=postgres 
DB_PASSWORD=tu_password_aqui 
DB_NAME=cocktails_db
```

3. **Base de Datos y Datos de Prueba (Importante)**

El sistema se encuentra configurado con ` synchronize: true ` (modo desarrollo), lo cual permite la creaciÃ³n automÃ¡tica de tablas al iniciar el servidor.

**Para la carga de datos iniciales (Semillas):** Dado que la sincronizaciÃ³n crea las tablas vacÃ­as, se deben seguir estos pasos para poblar la base de datos con ejemplos (Mojito, Margarita, etc.):

1. Asegurar la existencia de la base de datos (` cocktails_db `) en PostgreSQL.

2. Localizar el archivo ` init.sql ` dentro de la carpeta ` database/ `.

3. Copiar los scripts de inserciÃ³n (`INSERT INTO...`) y ejecutarlos manualmente en el gestor de base de datos preferido (pgAdmin, DBeaver o terminal).

## ğŸ› ï¸ Comandos Disponibles

**Iniciar en Desarrollo (Recomendado)**

Levanta el servidor con recarga automÃ¡tica (watch mode).

``` npm run dev```

La API estarÃ¡ disponible en: ` http://localhost:3000/api/cocktails `

**Ejecutar Pruebas (Testing)**

Ejecuta los tests de integraciÃ³n automatizados (Jest + Supertest) para validar el funcionamiento correcto del sistema (CRUD, Validaciones, Errores).

``` npm test``` 

**Compilar para ProducciÃ³n**

Genera el cÃ³digo JavaScript transpilado en la carpeta ` build/ `.

``` npm run build ``` 

## ğŸ“‚ Estructura del Proyecto

La organizaciÃ³n de carpetas sigue una arquitectura modular para separar responsabilidades:

```
backend/
â”œâ”€â”€ build/                 # CÃ³digo compilado para producciÃ³n
â”œâ”€â”€ database/              # Scripts SQL y datos de ejemplo (Seeds)
â”œâ”€â”€ node_modules/          # Dependencias del proyecto
â”œâ”€â”€ src/                   # CÃ³digo fuente TypeScript
â”‚   â”œâ”€â”€ controllers/       # Controladores: Manejan la entrada/salida HTTP
â”‚   â”œâ”€â”€ dtos/              # DTOs: Estructuras de datos (Input/Output)
â”‚   â”œâ”€â”€ entities/          # Entidades: Modelos de BD (TypeORM)
â”‚   â”œâ”€â”€ mappers/           # Mappers: TransformaciÃ³n DTO <-> Entidad
â”‚   â”œâ”€â”€ repositories/      # Repositorios: Acceso a datos
â”‚   â”œâ”€â”€ routes/            # Rutas: DefiniciÃ³n de endpoints
â”‚   â”œâ”€â”€ services/          # Servicios: LÃ³gica de negocio y validaciones
â”‚   â”œâ”€â”€ utils/             # Utilidades: Herramientas globales (AppError)
â”‚   â”œâ”€â”€ app.ts             # ConfiguraciÃ³n de la app Express
â”‚   â”œâ”€â”€ data-source.ts     # ConexiÃ³n a PostgreSQL
â”‚   â””â”€â”€ index.ts           # Punto de entrada: Inicia el servidor
â”œâ”€â”€ tests/                 # Pruebas de integraciÃ³n
â”œâ”€â”€ .env                   # Variables de entorno (Credenciales)
â”œâ”€â”€ jest.config.js         # ConfiguraciÃ³n de Jest
â”œâ”€â”€ package.json           # Dependencias y scripts
â””â”€â”€ tsconfig.json          # ConfiguraciÃ³n de TypeScript
```

## ğŸ§  Decisiones TÃ©cnicas y Arquitectura

A continuaciÃ³n, se detalla el razonamiento detrÃ¡s del diseÃ±o del software:

1. **Arquitectura por Capas**

Se optÃ³ por separar el cÃ³digo en tres capas principales (Controller, Service, Repository) para cumplir con el principio de SeparaciÃ³n de Responsabilidades:

- **Controller:** Su Ãºnica funciÃ³n es gestionar la comunicaciÃ³n HTTP (recibir `req`, enviar `res`). No contiene lÃ³gica de negocio ni consultas SQL.

- **Service:** Contiene la lÃ³gica de negocio pura (ej: validaciÃ³n de duplicados, limpieza de datos). ActÃºa como intermediario y desconoce si la peticiÃ³n viene de web o consola.

- **Repository:** Se encarga exclusivamente de la interacciÃ³n con la base de datos.

**Ventaja:** Esta estructura facilita el mantenimiento y permite cambiar componentes (como el framework web o la base de datos) con mÃ­nimo impacto en el resto del sistema.

2. **Flujo de Datos**

El dato viaja de manera controlada y transformada para proteger la integridad del sistema:

1. **Cliente:** EnvÃ­a la peticiÃ³n JSON.

2. **Controller:** Recibe la peticiÃ³n y delega al Service.

3. **Service:** Valida las reglas de negocio y utiliza el Mapper para convertir el DTO de entrada en una Entidad de dominio.

4. **Repository:** Persiste la Entidad en la Base de Datos.

5. **Respuesta:** El camino inverso utiliza nuevamente el Mapper para convertir la Entidad guardada en un DTO de respuesta, ocultando datos sensibles si fuera necesario.

3. InversiÃ³n de Control y Principios SOLID

Se aplicÃ³ el principio de **InversiÃ³n de Dependencias** de manera manual:

- Los Controladores no instancian la lÃ³gica de base de datos directamente, sino que dependen de una abstracciÃ³n (el Servicio) para realizar las operaciones.

- Esto desacopla las capas, haciendo el cÃ³digo mÃ¡s modular y facilitando la creaciÃ³n de pruebas unitarias y de integraciÃ³n.

4. **Robustez y Seguridad**

- **Identificadores UUID:** Se utilizaron UUIDs en lugar de IDs autoincrementales para mejorar la seguridad y evitar la enumeraciÃ³n de recursos.

- **Soft Delete:** Se implementÃ³ un borrado lÃ³gico para preservar la integridad histÃ³rica de los datos, permitiendo su restauraciÃ³n y auditorÃ­a.

- **Validaciones:** Se estableciÃ³ una doble capa de validaciÃ³n: restricciones UNIQUE a nivel de base de datos y validaciones lÃ³gicas descriptivas en la capa de Servicio.